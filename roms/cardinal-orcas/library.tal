(
@|operators )


@op-a "A "Outputs 20 "sum 20 "of 20 "inputs $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( a ) ports/get-left1-val
	( b ) STH2kr ports/get-right1-case ,&case STR
	( res ) ADD
	[ LIT &case $1 ] set-case STH2r !ports/<set-output-below>

@op-b "B "Outputs 20 "difference 20 "of 20 "inputs $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( a ) ports/get-left1-val
	( b ) STH2kr ports/get-right1-case ,&case STR
	( res ) SUB DUP #80 LTH ?{ #24 SWP SUB }
	[ LIT &case $1 ] set-case STH2r !ports/<set-output-below>

@op-c "C "Outputs 20 "modulo 20 "of 20 "frame $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2
	.Types/op STH2kr types/<set>
	.timer/frame LDZ2
	#00 ( rate* ) STH2kr ports/get-left1-val ( min1* ) EQUk ADD DIV2
	#00 ( mod* ) STH2kr ports/get-right1-case ,&case STR ( min1* ) EQUk ADD
	( mod2 ) [ DIV2k MUL2 SUB2 ]
	( res ) NIP
	[ LIT &case $1 ] set-case STH2r !ports/<set-output-below>

@op-d "D "Bangs 20 "on 20 "modulo 20 "of 20 "frame $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2
	.Types/op STH2kr types/<set>
	.timer/frame LDZ2
	#00 ( rate* ) STH2kr ports/get-left1-val ( min1* ) EQUk ADD
	#00 ( mod* ) STH2kr ports/get-right1-val ( min1* ) EQUk ADD
	( mod2 ) MUL2 [ DIV2k MUL2 SUB2 ] #0000 EQU2
	( bang ) [ LIT2 "*. ] ROT [ JMP SWP POP ]
	STH2r !ports/<set-output-below>

@op-e "E "Moves 20 "eastward 20 "or 20 "bangs $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	grid/get ,&self STR
	( wall ) .head/x LDZ INC .grid/width LDZ EQU ?&collide
	( cell ) STH2kr INC2 grid/get LIT ". NEQ ?&collide
	( write new ) [ LIT &self $1 ] STH2kr INC2 ports/<set-raw>
	( bang output )
	LIT "* STH2r !ports/<set-output>
	&collide
	( send x, y, cps )
	LIT 45 .Console/write DEO
	.head/x LDZ .Console/write DEO
	.head/y LDZ .Console/write DEO
	.timer/speed LDZ .Console/write DEO
	( erase old ) LIT ". STH2r !ports/<set-raw>
	JMP2r

@op-f "F "Bangs 20 "if 20 "inputs 20 "are 20 "equal $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( a ) ports/get-left1-raw
	( b ) STH2kr ports/get-right1-raw
	( bang ) EQU [ LIT2 "*. ] ROT [ JMP SWP POP ]
	STH2r !ports/<set-output-below>

@op-g "G "Writes 20 "operands 20 "with 20 "offset $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( x ) STH2kr #0003 SUB2 ports/get-left-val
		( load ) #00 SWP ADD2
	( y ) STH2kr #0002 SUB2 ports/get-left-val
		( load ) #00 SWP INC2 get-row ADD2
	,&save STR2
	( len ) STH2kr ports/get-left1-val ( min1 ) DUP #00 EQU ADD
	#00
	&>l
		( load ) #00 OVR STH2kr INC2 ADD2 ports/get-right-raw
		( save ) OVR #00 SWP [ LIT2 &save $2 ] ADD2 ports/<set-output>
		INC GTHk ?&>l
	POP2
	POP2r
	JMP2r

@op-h "H "Holds 20 "southward 20 "operand $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( cell ) below grid/get
	STH2r !ports/<set-output-below>

@op-i "I "Increments 20 "southward 20 "operand $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( step ) ports/get-left1-val
	( mod ) STH2kr ports/get-right1-case ,&case STR
		( min1 ) DUP #00 EQU ADD
	( res ) SWP STH2kr below grid/get chrb36 ADD SWP
	( MOD ) [ DIVk MUL SUB ]

	[ LIT &case $1 ] set-case STH2r !ports/<set-output-below>

@op-j "J "Outputs 20 "northward 20 "operand $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( get above ) above ports/get-left-raw
	( ignore cable ) DUP [ LIT "J ] NEQ ?{ POP POP2r JMP2r }
	( skip down )
	STH2r
	&>w
		below DUP2 grid/get chrb36 #13 EQU
		?&>w

	!ports/<set-output>

@op-k "K "Reads 20 "multiple 20 "variables $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	ports/get-left1-val #00
	&>l
		#00 OVR STH2kr INC2 ADD2 STH2k ports/get-right-raw
		DUP LIT ". EQU ?{
			( load ) DUP chrb36 variables/get
			( save ) STH2kr ports/<set-output-below>
			}
		POP
		POP2r
		INC GTHk ?&>l
	POP2
	POP2r

	JMP2r

@op-l "L "Outputs 20 "smallest 20 "of 20 "inputs $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( a ) ports/get-left1-val
	( b ) STH2kr ports/get-right1-case ,&case STR
	( res ) [ LTHk JMP SWP POP ]

	[ LIT &case $1 ] set-case STH2r !ports/<set-output-below>

@op-m "M "Outputs 20 "product 20 "of 20 "inputs $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( a ) ports/get-left1-val
	( b ) STH2kr ports/get-right1-case ,&case STR
	( res ) MUL

	[ LIT &case $1 ] set-case STH2r !ports/<set-output-below>

@op-n "N "Moves 20 "Northward 20 "or 20 "bangs $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	grid/get ,&self STR
	( wall ) .head/y LDZ #01 SUB #ff EQU ?&collide
	( cell ) STH2kr above grid/get LIT ". NEQ ?&collide
	( write new ) [ LIT &self $1 ] STH2kr above ports/<set-raw>
	( bang output )
	LIT "* STH2r !ports/<set-output>
	&collide
	( send x, y, cps )
	LIT 4e .Console/write DEO 
	.head/x LDZ .Console/write DEO
	.head/y LDZ .Console/write DEO
	.timer/speed LDZ .Console/write DEO
	( erase old ) LIT ". STH2r !ports/<set-raw>
	JMP2r

@op-o "O "Reads 20 "operand 20 "with 20 "offset $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( x ) STH2kr #0002 SUB2 ports/get-left-val INC #00 SWP ADD2
	( y ) STH2kr ports/get-left1-val #00 SWP get-row ADD2
	( val ) ports/get-right-raw

	STH2r !ports/<set-output-below>

@op-p "P "Writes 20 "eastward 20 "operand $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( key ) #0002 SUB2 ports/get-left-val
	( len ) STH2kr ports/get-left1-val ( min1 ) DUP #00 EQU ADD
	#00
	&>l
		#00 OVR STH2kr below ADD2 ports/<set-lock>
		INC GTHk ?&>l
	POP
	( read ) STH2kr ports/get-right1-raw
	ROT ROT
	( MOD ) [ DIVk MUL SUB ] #00 SWP STH2r below ADD2

	!ports/<set-output>

@op-q "Q "Reads 20 "operands 20 "with 20 "offset $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( x ) STH2kr #0003 SUB2 ports/get-left-val
		( load ) #00 SWP INC2 ADD2
	( y ) STH2kr #0002 SUB2 ports/get-left-val
		( load ) #00 SWP get-row ADD2
	,&load STR2
	( len ) STH2kr ports/get-left1-val ( min1 ) DUP #00 EQU ADD
		( save ) #00 OVR STH2kr below SWP2 SUB2 INC2 ,&save STR2
	#00
	&>l
		( load ) #00 OVR [ LIT2 &load $2 ] ADD2 ports/get-right-raw
		( save ) OVR #00 SWP [ LIT2 &save $2 ] ADD2 ports/<set-output>
		INC GTHk ?&>l
	POP2
	POP2r

	JMP2r

@op-r "R "Outputs 20 "random 20 "value $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( a-min ) ports/get-left1-val
	( b-max ) STH2kr ports/get-right1-case ,&case STR
		( min1 ) DUP #00 EQU ADD
	( mod ) OVR SUB random/generate ADD SWP ( min1 ) DUP #00 EQU ADD
	( MOD ) [ DIVk MUL SUB ] ADD

	[ LIT &case $1 ] set-case STH2r !ports/<set-output-below>

@op-s "S "Moves 20 "southward 20 "or 20 "bangs $1
    &lc get-bang ?&* POP2 JMP2r &*

    STH2k .Types/op STH2kr types/<set>
    grid/get ,&self STR
    ( wall ) .head/y LDZ INC .grid/height LDZ EQU ?&collide-wall
    ( cell ) STH2kr below grid/get LIT ". NEQ ?&collide
    ( write new ) [ LIT &self $1 ] STH2kr below ports/<set-raw>
    ( erase old ) LIT ". STH2r !ports/<set-raw>

    &collide-wall
      .head/x LDZ .Console/write DEO
      .head/y LDZ .Console/write DEO
      .timer/speed LDZ .Console/write DEO
    &collide
      LIT "* STH2r !ports/<set-output>

@op-t "T "Reads 20 "eastward 20 "operand $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( key ) #0002 SUB2 ports/get-left-val
	( len ) STH2kr ports/get-left1-val ( min1 ) DUP #00 EQU ADD
	#00
	&>l
		#00 OVR STH2kr INC2 ADD2 ports/<set-lock>
		INC GTHk ?&>l
	POP
	( read )
	( MOD ) [ DIVk MUL SUB ] #00 SWP STH2kr INC2 ADD2 ports/get-right-raw

	STH2r !ports/<set-output-below>

@op-u "U "Bangs 20 "on 20 "Euclidean 20 "rhythm $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( step ) ports/get-left1-val
	( max ) STH2kr ports/get-right1-val ( min1 ) DUP #00 EQU ADD STH2
	( frame ADD max SUB 1 ) .timer/frame LDZ2 #00 STHkr ADD2 #0001 SUB2
	( MUL step ) OVRr #00 STHr MUL2
	( % max ) #00 STHkr
	( mod2 ) [ DIV2k MUL2 SUB2 ]
	( ADD step ) SWPr #00 STHr ADD2
	( bucket GTH= max ) #00 STHr LTH2 #01 NEQ
	( bang if equal ) #fc MUL LIT ". ADD

	STH2r !ports/<set-output-below>

@op-v "V "Reads 20 "and 20 "writes 20 "variable $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( key ) ports/get-left1-raw
	( val ) STH2kr ports/get-right1-raw
	DUP LIT ". EQU ?&idle
	OVR LIT ". EQU ?&load
	( save )
		SWP chrb36 variables/<set> POP2r JMP2r
	&load
		NIP chrb36 variables/get STH2r below !ports/<set-output>
	&idle
		POP2 POP2r

	JMP2r

@op-w "W "Moves 20 "westward 20 "or 20 "bangs $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	grid/get ,&self STR
	( wall ) .head/x LDZ #01 SUB #ff EQU ?&collide
	( cell ) STH2kr #0001 SUB2 grid/get LIT ". NEQ ?&collide
	( write new ) [ LIT &self $1 ] STH2kr #0001 SUB2 ports/<set-raw>
	( bang output )
	LIT "* STH2r !ports/<set-output>
	&collide
	( send x, y, cps )
	LIT 57 .Console/write DEO
	.head/x LDZ .Console/write DEO
	.head/y LDZ .Console/write DEO
	.timer/speed LDZ .Console/write DEO
	( erase old ) LIT ". STH2r !ports/<set-raw>
	JMP2r

@op-x "X "Writes 20 "operand 20 "with 20 "offset $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( x ) STH2kr #0002 SUB2 ports/get-left-val #00 SWP ADD2
	( y ) STH2kr ports/get-left1-val INC #00 SWP get-row ADD2
	( val ) STH2r ports/get-right1-raw
	ROT ROT

	!ports/<set-output>

@op-y "Y "Outputs 20 "westward 20 "operand $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( get above ) ports/get-left1-raw
	( ignore cable ) DUP [ LIT "Y ] NEQ ?{ POP POP2r JMP2r }
	( skip down )
	STH2r
	&>w
		INC2 DUP2 grid/get chrb36 #22 EQU
		?&>w

	!ports/<set-output>

@op-z "Z "Transitions 20 "operand 20 "to 20 "input $1
	&lc get-bang ?&* POP2 JMP2r &*

	STH2k .Types/op STH2kr types/<set>
	( rate ) ports/get-left1-val
	( target ) STH2kr ports/get-right1-case ,&case STR
	( val ) STH2kr below grid/get chrb36
	( res ) lerp

	[ LIT &case $1 ] set-case STH2r !ports/<set-output-below>

(
@|special )

@op-bang "* "Bangs 20 "neighboring 20 "operands $1
	&*
	LIT ". ROT ROT
	grid/<set> JMP2r

@op-comment "# "Comments 20 "a 20 "line $1
	&*
	STH2k
	( set itself )
	DUP2 ports/<set-lock>
	( get edge )
	[ LIT2 00 -grid/width ] LDZ .head/x LDZ SUB ADD2
	STH2r INC2
	&>l
		DUP2 ports/<set-lock>
		( stop at hash ) DUP2 grid/get LIT "# EQU ?&end
		INC2 GTH2k ?&>l
	&end
	POP2 POP2
	JMP2r

@op-midi ": "Send 20 "a 20 "midi 20 "note $1
	&*

	INC2k STH2k
	( channel ) ports/get-right-val ,&chn STR
	( octave ) INC2r STH2kr ports/get-right-val #0c MUL
	( note ) INC2r STH2kr ports/get-right-raw chrmid ADD ,&pitch STR
	( velocity ) INC2r STH2kr ports/get-right-raw chrvel ,&vel STR
	( length ) INC2r STH2r ports/get-right-val INC ,&len STR
	get-bang ?&has-bang POP2 JMP2r &has-bang
	,&pitch LDR ?&has-pitch POP2 JMP2r &has-pitch
	.Types/io ROT ROT types/<set>
	[ LIT2 &chn $1 &pitch $1 ] [ LIT2 &len $1 &vel $1 ] !voices/<add>

@op-pitch "; "Send 20 "a 20 "raw 20 "pitch 20 "byte $1
	&*

	STH2k
	( octave ) ports/get-right1-val
	( note ) STH2kr INC2 ports/get-right1-raw
	( has note ) DUP LIT ". NEQ ?&has-note [ POP2 POP2r JMP2r ] &has-note
	( has bang ) get-bang ?&is-bang [ POP2 POP2r JMP2r ] &is-bang
	( animate ) .Types/io STH2r types/<set>
	( get note ) chrmid SWP [ #0c MUL ] ADD .Console/write DEO

	JMP2r


@op-byte "/ "Send 20 "a 20 "raw 20 "hexadecimal 20 "byte $1
	&*

	STH2k
	( hn ) ports/get-right1-val
	( ln ) STH2kr INC2 ports/get-right1-val
	( has bang ) get-bang ?&is-bang [ POP2 POP2r JMP2r ] &is-bang
	( animate ) .Types/io STH2r types/<set>

	( send op codes first )
	#0f AND SWP #0f AND #40 SFT ADD .Console/write DEO

	( then send x, y, cps )
	LIT "S .Console/write DEO
	.head/x LDZ .Console/write DEO
	.head/y LDZ .Console/write DEO
	.timer/speed LDZ .Console/write DEO
	JMP2r

@op-self "$ "Load 20 "orca 20 "file $1
	&*
	STH2k
	;&buf ,&ptr STR2
	&>w
		INC2
		DUP2 ;grid/buf ADD2 LDA2 LIT2 ".. EQU2 ?&end
		DUP2 ports/get-right-raw DUP /<push> ?&>w
	&end
	POP2
	#00 /<push>
	get-bang ?{ POP2r JMP2r }
	.head/pos LDZ2 INC ;&buf file/<inject>
	.Types/io STH2r types/<set> JMP2r

@op-self/<push> ( c -- )
	[ LIT2 &ptr =&buf ] INC2k ,&ptr STR2
	STA JMP2r

@op-null
	POP2
	JMP2r

~assets.tal

